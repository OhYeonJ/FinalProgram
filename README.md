B677017 게임소프트웨어 전공 오연주

유튜브 링크 : https://www.youtube.com/watch?v=3z3gvCSnFq4&feature=youtu.be
(수정 예정입니다.)
 
타이틀 : Repeat 
장르 : 2D 횡스크롤 호러 방탈출
플랫폼 : 클라이언트 
타겟 플레이어 : 스토리가 가미된 호러 2D게임을 좋아하는 유저들

개요 : 
 “Repeat”는 자신이 죽었음을 알지 못하는 주인공이 죽음 이후 잃어버린 기억을 찾아 자신의 집 모습을 하고 있는 이공간을 떠돌아다니게 된다. 주인공이 이공간을 탈출하는 것을 방해하는 귀신들과 마주치거나 피해야하며, 잠긴 방문을 열고 기억을 되찾으며 최종적으로 현관문을 열고 성불해야하는 스토리의 3인칭 2D 횡스크롤 약호러 장르의 게임이다. 본 게임은 튜토리얼, 1스테이지, 2스테이지 총 3개의 스테이지가 존재한다.

기획적 특징

- 게임 배경 :
  일설에 따르면 마음의 준비를 할 새도 없이 순식간에 사고사로 죽으면 원혼은 자신이 죽은 줄도 모른 채로 같은 장소에서 자신이 죽은 그 시간을 계속해서 반복한다고 한다. 게임의 배경은 이승과 저승의 사이에 존재한다고 하는 공간인 연옥과도 같은 공간이다. (엄연히 말하자면 연옥과는 다르다. 연옥은 가톨릭 세계관에서 남은 죄를 불로써 없애는 공간이므로. 주인공은 죄가 없다. ) 주인공은 퇴근한 직후 소파에서 잠이 들었다가 침입한 괴한에 의해 사망했다. 피곤함에 찌들어 깊게 잠든 사이에 일어난 일이기에 주인공은 자신의 죽음을 전혀 알지 못한다. 이를 깨닫지 못한채로 주인공은 집에서 (물론 주인공은 자신이 현재 있는 곳이 자신의 집의 형상을 띈 이공간이라는 것도 알지 못한다.) 영문도 모른채로 악령들에게 당하고, 겨우 겨우 열쇠를 얻어 현관문을 통해 집을 탈출한다. 하지만 현관문을 열어도 나오는 것은 바깥이 아니라 또 다시 자신의 집 안일 뿐이다. 이유는 하나다. 자신이 죽은 것을 깨닫지도, 기억을 되찾지도 못했기 때문이다. 
  
- 게임 시나리오 :
주인공은 일을 마치고 집으로 돌아왔다. 오늘따라 피로감이 주인공의 눈꺼풀을 짓누른다. 주인공은 씻지도 않은 채로 소파에 늘어져 잠시 눈을 붙인다. 
얼마나 지났을까? 주인공은 갈증을 느끼고 천천히 눈을 뜬다. 물을 마시기 위해 부엌으로 가던 도중 자신이 옷도 갈아입지 않았음을 깨닫고 침실로 향한다. 그러나 분명히 열려있을 터인 침실의 방문은 열리지 않고, 개방형인 부엌을 제외하고는 집 안의 그 어떤 문도 열리지 않는다. 방문을 잠글 필요가 없이 혼자 살고있는 자신의 집임에도 말이다. 심지어 서재의 문은 열쇠 구멍조차 보이지 않는다. 
잠시 무슨 일이 있었나 기억을 더듬어보지만, 이상하게도 퇴근하고 집에 돌아왔다는 것 이외에는 아무것도 기억이 나지 않는다. 자신은 누구인지, 방금 전까지 무엇을 하고 있었는지. 기억나는 것은 오직 자신의 집이라는 곳에 자신이 존재하고 있다는 것. 주인공은 불안한 마음에 복도를 돌아다니다가 심상치 않음을 느끼고 현관문을 열려고 하지만 역시나 다른 문들처럼 열리지 않는다. 와중에 집 안에서는 이따금씩 이상한 울음소리도 들리고 휴대전화는 먹통이다. 공포에 휩싸인 주인공은 외부에 구조를 요청하기 위해 어떻게 해서든 탈출해야겠다고 마음을 먹는다. 

- 그래픽 : 
본인만의 스토리 구축을 위하여 게임 내에 사용된 모든 스프라이트들은 SAItool과 ClipStudio 프로그램을 사용하여 직접 제작하였다. 사후세계를 표현하기 위해 붉은 색 계열을 사용하였으며, 주인공이 이미 죽었다는 것을 표현하기 위해 맵과 비슷한 분위기의 분홍색~갈색 계열을 사용하여 유령처럼 보이게끔 디자인하였다. 또한 주인공 캐릭터는 이목구비를 그려넣지 않아 위화감을 조성하게끔 하였다. 다만 적 오브젝트들 스프라이트들의 그림체가 극명하게 차이가 나는데 이는 작업 중에 초반에 기획했던 내용이 틀어지게 되어 일어난 일이다. 
- 단조로운 카메라와 UI
카메라 워크를 단조롭게 하였고 UI가 눈에 띄지 않게 하였다. 이것은 플레이어가 게임에 조금 더 몰입할 수 있도록 한 것이며 플레이어가 주인공이 아니라 주인공을 관찰하는 귀신들의 시점이라는 것을 간접적으로 나타낸 것이다. 

기술적 특징

- 플레이어 객체 :
   Player 스크립트 내에서 가능한 모든 동작이 이루어질 수 있게끔 작성을 하였다. Player 오브젝트는 게임 내에서 파괴되지 않고 계속 씬을 이동해야하기 때문에 DontDestroyOnLoad로 파괴되지 않게 하였다. Transfer 스크립트와 연동하여 맵 이동 포인트에서 특정 키 입력 및 충돌 여부 결과를 받은 후에 씬 이동이 이루어질 경우 Player 스크립트의 currentMapName을 이동한 맵의 이름으로 초기화하여 현재 Player 오브젝트가 있는 곳을 설정하게 한다. 
   LayerMask는 Player 오브젝트가 맵을 벗어나지 못하게끔 BoxCollider에 NonPassing이라는 Layer 속성을 추가하여 Player 오브젝트와 NonPassing Collider가 충돌했을 경우에 이동을 저지하도록 하기 위해 추가하였다.  Player 오브젝트의 현재 위치 값을 start 좌표로 두고, 이동하고자 하는 위치의 값을 end좌표로 두어 NonPassing으로 지정된 Wall 오브젝트와 충돌했는지의 여부를 RaycastHit으로 받아와, 이동을 저지한다. 
Player 오브젝트는 GetAxisRaw("Horizontal")로 좌우 방향키만을 입력받아 MoveCoroutine이 실행된다. 키 입력이 이루어지는 동안에 Shit 키를 누르면 달리기가 가능해지게끔 달리기 = true 상태일 경우에 연산되는 증가 속도 변수를 두었고, 달리기 버튼이 눌렸는지 여부를 확인하기 위해 이를 bool로 체크하였다. 또한 Player의 현재 Vector값을 받아 파라미터로 전달하고, 이를 기반으로 걷기 애니메이션이 실행되도록 하였다. 그리고 Player 오브젝트가 움직일 px을 walkCount라는 public 변수와 speed값으로 연산하여 도출하도록 하였다. 이동시 Shift 입력 여부를 확인하여 speed 값을 추가하도록 하였다. canMove는 이동중 방향키 반복 실행 방지를 위한 값이고, notMove는 Dialogue가 실행되고 있을 경우에 플레이어의 움직임이 일시정지되도록 하는 값이다. 이 둘은 모두 bool로 상태를 체크하도록 하였다. 

- 카메라 : 
 BoxCollider로 일정 영역을 설정하여 Player 오브젝트를 따라다니는 카메라를 구현하였다. CameraMovement 스크립트에서 카메라가 따라갈 대상인 target과 대상의 현재 위치인 targetPosition을 각각 GameObject와 Vector값을 받아온다. 또한 카메라가 움직일 영역을 체크하기 위해 BoxCollider 클래스에서 bound 값을 가져와 BoxCollider 영역의 최대 또는 최소 x,y 값을 지니게 했고, 카메라의 반너비와 반높이 값을 지닐 변수를 작성하였다. 카메라의 반높이 값을 구할 속성을 이용하기 위한 변수로 Camera 클래스를 private로 가져왔다. 씬이 시작될 때마다 Camera 컴포넌트를 불러오고 BoxCollider의 최대 & 최소 영역, 카메라의 반높이와 해상도를 책정한다. Clamp를 사용하여 카메라 Bound Collider의 최대, 최소 x & y 값의 한계 내에서 Player 객체가 이동할때마다 카메라의 위치를 갱신하게끔 하였다. 
씬 이동이 이루어지더라도 계속해서 Player를 따라가게끔 Singleton을 적용하여 씬마다 적용해둔 Bound Collider객체를 받아올 수 있게 SetBound() 메서드를 작성하였다. 이 메서드는 씬 이동 스크립트인 TransferMap 스크립트에서 Player에게 특정 키 입력을 받았을 때 씬 이동이 이루어질 때 작동하게 된다. 씬 이동이 이루어질 경우에 MainCamera는 Singleton을 사용하였으므로 파괴되지 않으나, Bound Collider의 경우에는 DontDestroyOnLoad를 적용하지 않았기 때문에 씬을 넘어오면서 유실된다. 따라서 MainCamera가 Target인 Player 객체를 찾을 수 없게 되기 때문에 새 씬에 새 Bound Collider를 미리 만들어두고 씬 이동이 이루어질 경우에는 MainCamera가 새 씬의 새 Bound Collider를 받아오게끔 하는 것이 SetBound() 메서드가 수행하도록 하였다.

- 인벤토리 :
 인벤토리 시스템은 크게 네 가지로 구현하였다. 먼저 Player에게 보여지는 Inventory UI는 Grid Layout Group 컴포넌트를 사용하여 프리팹 오브젝트인 slot을 일정한 간격으로 묶어두게끔 하였다. Slot 박스의 위치들을 고정하고 이 위치값을 가져오기 위하여 SlotHolder라는 Transform을 가져오게 했다. I키를 입력하면 Inventory UI가 열리고 닫히게 하였고, FieldItem을 습득하거나 사용했을 경우에 소지 Item의 이미지를 추가된 순서대로 삽입, 또는 사용된 아이템의 이미지를 삭제하는 RedrawSlotUI() 메서드를 사용하였다. Slot 배열의 길이만큼 RemoveSlot()으로 배열의 요소를 초기화하거나 UpdateUI()로 배열에 요소를 추가하게끔 하였다. Inventory 스크립트에서 item의 출입 여부를 체크하고 상태를 변경하도록 하였다.      
 AddItem()에서 설정해둔 배열의 길이만큼 Slot을 체크하여 빈 slot이 있을 경우, 획득한 Item을 담을 items 리스트와 그 아이템의 타입을 담을 itemTypeList에 정보를 삽입한다. Delgate로 대리자를 호출하게 하여 아이템이 추가되면 Slot UI에도 아이템이 추가되게끔 하였다. 아이템 획득이 성공적으로 이루어졌을 때에 true 값을 반환하도록 하였다. ContainItem() 메서드는 Player가 특정 item으로 격파가 가능한 오브젝트와 상호작용이 이루어졌을 경우, List에 해당 타입의 item을 가지고 있는지의 여부를 체크한다. 
 RemoveItem()과 RemoveItemType() 메서드는 각각 itemUse() 메서드 체크로 item 사용 확인이 이루어졌을 경우에 각각의 List에서 해당 아이템의 정보를 모두 삭제하고 slot UI에서도 삭제할 수 있게끔 하였다. 대부분 상호작용 가능한 오브젝트들은 아이템들을 가지고 있어야만 하기 때문에 충돌 및 키 입력으로 인한 상호작용의 결과는 Inventory 스크립트에서 수행하게끔 하였다. Inventory에 특정 아이템이 있을 경우에는 Dialogue로 아이템을 사용했다는 문구가 뜨며 각 오브젝트들의 타입별 Interact 스크립트에서 Actived() 메서드가 작동하도록 하였다. Actived() 메서드가 작동하는 동시에 오브젝트들을 격파하고 사용된 item들의 정보를 삭제하게 하였다. 
 Slot 스크립트에서는 Slot UI 정보를 갱신하는 UpdateSlotUI() 메서드로 item의 이름과 이미지 스프라이트를 받아오게 하였고, RemoveSlot() 메서드로 슬롯 초기화 동작을 작성하였다. ToolTiP, ItemDataBase 스크립트를 참조하여 Slot 칸에 마우스가 올라갈 때 item tooltip 정보를 보이게하고, 마우스가 영역을 벗어나면 보이지 않게 하였다. 그리고 아이템 사용 여부를 받아와서 slot에서 item의 정보가 사라지게끔 한다. 
 ToolTip 스크립트는 Item 스크립트의 정보를 토대로 소지하고 있는 item의 이름과 설명을 열람할 수 있게 하였다. ItemDataBase 스크립트를 징검다리 역할로 두어 현재 소지중이고, database에 있는 내용들을 Player가 볼 수 있게 한다.

- 대화창 :
 DialogueManager 스크립트에서 ShowDialogue()는 대화 상태를 true로 하고 StartDialogueCoroutine으로 public으로 입력되어있는 대화문을 배열로 받아와서 배열의 길이만큼 한 글자씩, 0.01f 정도의 텀을 두어 출력하도록 하였다. 반대로 ExitDialogue()는 모든 변수값을 초기화하게 하였다. 대화는 Update() 메서드에서 특정 키 값을 받았을 경우에 대화 카운트를 증가시키고 대화창을 초기화하여 다음 대화 텍스트를 StartDialogueCoroutine으로 불러오게 하였다. Player 오브젝트가 대화중에 움직이지 못하게 하기 위해 상기한 notmove() 메서드로 하여금 talk = true일 동안은 움직이지 못하도록 하였다. 
 SingleUseScript 스크립트는 이름이 Player인 객체와 충돌만 해도 이벤트가 일어나고 한 번 사용하면 대화 포인트가 파괴되게끔 하였다. 대화 도중에 포인트가 파괴되는 것을 방지하기 위해 Invoke 함수로 포인트가 파괴되는 시간을 지연 적용하였다. 반면에 충돌과 키 입력이 동시에 일어나야 이벤트가 발생하는 포인트의 경우의 GameScript 스크립트는 키 입력 조건만을 덧붙여 적용하였다. 
Dialogue 커스텀 스크립트에 대화창 스크립트를 적용할 수 있게 하였고, 문장들을 배열로 만들고 대화문이 여러 줄로 표시될 수 있게끔 TextArea로 영역을 설정하였다.
  
- 인터렉팅 : 
 상호작용이 필요한 오브젝트의 경우 크게 두 가지로 나뉜다. 첫 번째로 특정 key item을 필요로 하는 Door 오브젝트와 특정 아이템으로 격파가 가능한 Eenemy 오브젝트가 있다. Key item으로 상호작용을 하여 잠긴 문을 열수 있게 하는 포인트 역할을 하는 DoorInteract 스크립트는 Item 스크립트의 ItemType 정보와 Item 정보를 받아오는 메서드를 적용하였고, item이 사용되었을 시 효과를 적용하는 itemActived() 메서드를 작성하였다. itemActived() 메서드의 경우, 문을 통하여 다른 씬으로 이동할 수 있게끔 Transfer 스크립트 & StartPoint 스크립트와 연동되게 하였다. 이는 tranferMapName string 변수와 player.currentName 변수로 연동이 된다. 로딩 Scene을 작성하여 다른 Scene의 오브젝트들이 불려오는 동안 유예시간을 갖게끔 LoadSceneManager 스크립트를 작성하였다. 
 EnemyInteract 스크립트는 DoorInteract 스크립트의 isActived() 메서드만을 변경한 것으로, 이는 Enemy 오브젝트의 격파를 위한 스크립트이기 때문에 상호작용이 이루어졌을 경우 해당 스크립트를 가지고 있는 Eenemy 오브젝트들이 파괴되도록 하였다. 이 오브젝트들이 파괴될 경우, 각 씬에 존재하는 roomManager가 다음 오브젝트들을 불러오게 하였다 (적을 퇴치하면 튀어나오는 새로운 Key item과 이미지 스프라이트). 단일 스크립트만으로 이벤트가 불가능한 Enemy Event의 경우 Scene마다  Event Object에 Event를 담당하는 Script를 작성하여 연결다리 역할을 수행하도록 하였다. 
 
- 기타 UI : 
  TitleMenu의 Start, Tutorial 버튼은 Loading Scene을 끼우고 각각의 씬을 불러오게 하였으며, Start의 경우 start cut scene을 걸쳐서 stage1로 진입하게 하였다. Pause 버튼 또한 플레이 도중에 Pause 키로 설정해둔 ESC 버튼을 누르면 Pause창이 뜨고 닫히게 하였고, paused = true면 timeScale을 0으로 하여 게임이 일시정지 되게끔 하였다. Continue()는 0이 된 timeScale을 다시 1f로 변경하여 게임이 계속 되도록 하였고, Quit()는 TitelMenu로 씬 이동이 이루어지게 하였다. 
아이템 상호작용 포인트를 나타내기 위해 튜토리얼과 stage1에 가이드 버튼 UI를 적용하였다. 가이드 버튼 오브젝트를 public으로 받아와서 Player 오브젝트가 버튼 Collider 영역 내에 들어와있을 경우 해당 영역이 상호작용 포인트라는 것을 알리는 키 버튼 스프라이트를 보이게 하였다. 반대로 영역에서 나갔을 경우에는 꺼지도록 하였다. 다만 Button Sprite에 키를 누르도록 유도하기 위한 깜빡임 애니메이션이 거슬리는 점이 되어 이 부분은 수정하였다.

게임 사운드 소스 출처 : http://soundbible.com / YouTube 오디오 라이브러리 
게임 내 사용 폰트: 한글 폰트 - DX신문명조_TT / 영어 폰트 - 빛의 계승자 
본문 사용 폰트 : 나눔스퀘어

